<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Denotational (Isabelle2020: April 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Denotational</h1>

<span class="command">theory</span> <span class="name">Denotational</span><br/>
<span class="keyword">imports</span> <a href="Run.html"><span class="name">Run</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Denotational Semantics&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Denotational</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span>TESL</span><span>
</span><span>    </span><span>Run</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  The denotational semantics maps TESL formulae to sets of satisfying runs.
  Firstly, we define the semantics of atomic formulae (basic constructs of the 
  TESL language), then we define the semantics of compound formulae as the
  intersection of the semantics of their components: a run must satisfy all
  the individual formulae of a compound formula.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Denotational interpretation for atomic TESL formulae&#8250;</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>dummyT0</span><span> </span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;&#964; tag_const&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>dummyDeltaT</span><span> </span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;&#964; tag_const&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>dummyT0</span><span>     </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;t<span class="hidden">&#8681;</span><sub>0</sub>&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>dummyDeltaT</span><span> </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#948;t&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>TESL_interpretation_atomic</span><span>
</span><span>    </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;&#964;::linordered_field) TESL_atomic &#8658; &#39;&#964; run set&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; _ &#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="comment">&#8213; &#8249;@{term &#8249;C<span class="hidden">&#8681;</span><sub>1</sub> sporadic &#964; on C<span class="hidden">&#8681;</span><sub>2</sub>&#8250;} means that @{term &#8249;C<span class="hidden">&#8681;</span><sub>1</sub>&#8250;} should tick at an 
      instant where the time on @{term &#8249;C<span class="hidden">&#8681;</span><sub>2</sub>&#8250;} is @{term &#8249;&#964;&#8250;}.&#8250;</span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; C<span class="hidden">&#8681;</span><sub>1</sub> sporadic &#964; on C<span class="hidden">&#8681;</span><sub>2</sub> &#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> =
        {&#961;. &#8707;n::nat. ticks ((Rep_run &#961;) n C<span class="hidden">&#8681;</span><sub>1</sub>) &#8743; time ((Rep_run &#961;) n C<span class="hidden">&#8681;</span><sub>2</sub>) = &#964;}&#8250;</span></span></span><span>
</span><span>  </span><span class="comment">&#8213; &#8249;@{term &#8249;time-relation &#8970;C<span class="hidden">&#8681;</span><sub>1</sub>, C<span class="hidden">&#8681;</span><sub>2</sub>&#8971; &#8712; R&#8250;} means that at each instant, the time 
      on @{term &#8249;C<span class="hidden">&#8681;</span><sub>1</sub>&#8250;} and the time on @{term &#8249;C<span class="hidden">&#8681;</span><sub>2</sub>&#8250;} are in relation~@{term &#8249;R&#8250;}.&#8250;</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; time-relation &#8970;C<span class="hidden">&#8681;</span><sub>1</sub>, C<span class="hidden">&#8681;</span><sub>2</sub>&#8971; &#8712; R &#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> =
        {&#961;. &#8704;n::nat. R (time ((Rep_run &#961;) n C<span class="hidden">&#8681;</span><sub>1</sub>), time ((Rep_run &#961;) n C<span class="hidden">&#8681;</span><sub>2</sub>))}&#8250;</span></span></span><span>
</span><span>  </span><span class="comment">&#8213; &#8249;@{term &#8249;master implies slave&#8250;} means that at each instant at which 
      @{term &#8249;master&#8250;} ticks, @{term &#8249;slave&#8250;} also ticks.&#8250;</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; master implies slave &#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> =
        {&#961;. &#8704;n::nat. ticks ((Rep_run &#961;) n master) &#10230; ticks ((Rep_run &#961;) n slave)}&#8250;</span></span></span><span>
</span><span>  </span><span class="comment">&#8213; &#8249;@{term &#8249;master implies not slave&#8250;} means that at each instant at which 
      @{term &#8249;master&#8250;} ticks, @{term &#8249;slave&#8250;} does not tick.&#8250;</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; master implies not slave &#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> =
        {&#961;. &#8704;n::nat. ticks ((Rep_run &#961;) n master) &#10230; &#172;ticks ((Rep_run &#961;) n slave)}&#8250;</span></span></span><span>
</span><span>  </span><span class="comment">&#8213; &#8249;@{term &#8249;master time-delayed by &#948;&#964; on measuring implies slave&#8250;} means that 
      at each instant at which  @{term &#8249;master&#8250;} ticks, @{term &#8249;slave&#8250;} will
      tick after a delay @{term &#8249;&#948;&#964;&#8250;} measured on the time scale 
      of @{term &#8249;measuring&#8250;}.&#8250;</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; master time-delayed by &#948;&#964; on measuring implies slave &#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> =
    &#8213; &#8249;
      When master ticks, let&#39;s call @{term &#8249;t<span class="hidden">&#8681;</span><sub>0</sub>&#8250;} the current date on measuring. Then, 
      at the first instant when the date on measuring is @{term &#8249;t<span class="hidden">&#8681;</span><sub>0</sub>+&#948;t&#8250;}, 
      slave has to tick.
    &#8250;
        {&#961;. &#8704;n. ticks ((Rep_run &#961;) n master) &#10230;
                 (let measured_time = time ((Rep_run &#961;) n measuring) in
                  &#8704;m &#8805; n.  first_time &#961; measuring m (measured_time + &#948;&#964;)
                            &#10230; ticks ((Rep_run &#961;) m slave)
                 )
        }&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; master time-delayed&#10781; by &#948;&#964; on measuring implies slave &#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> =
    &#8213; &#8249;
      When master ticks, let&#39;s call @{term &#8249;t<span class="hidden">&#8681;</span><sub>0</sub>&#8250;} the current date on measuring. Then, 
      slave will be ticking at some instant(s) when the time on measuring is @{term &#8249;t<span class="hidden">&#8681;</span><sub>0</sub>+&#948;t&#8250;}.
    &#8250;
        { &#961;. &#8704;n. ticks ((Rep_run &#961;) n master) &#10230;
                 (let measured_time = time ((Rep_run &#961;) n measuring) in
                  &#8707;m &#8805; n. ticks ((Rep_run &#961;) m slave)
                          &#8743; time ((Rep_run &#961;) m measuring) = measured_time + &#948;&#964;
                 )
        }&#8250;</span></span></span><span>
</span><span>  </span><span class="comment">&#8213; &#8249;@{term &#8249;C<span class="hidden">&#8681;</span><sub>1</sub> weakly precedes C<span class="hidden">&#8681;</span><sub>2</sub>&#8250;} means that each tick on @{term &#8249;C<span class="hidden">&#8681;</span><sub>2</sub>&#8250;}
        must be preceded by or coincide with at least one tick on @{term &#8249;C<span class="hidden">&#8681;</span><sub>1</sub>&#8250;}.
        Therefore, at each instant @{term &#8249;n&#8250;}, the number of ticks on @{term &#8249;C<span class="hidden">&#8681;</span><sub>2</sub>&#8250;} 
        must be less or equal to the number of ticks on @{term &#8249;C<span class="hidden">&#8681;</span><sub>1</sub>&#8250;}.&#8250;</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; C<span class="hidden">&#8681;</span><sub>1</sub> weakly precedes C<span class="hidden">&#8681;</span><sub>2</sub> &#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> =
        {&#961;. &#8704;n::nat. (run_tick_count &#961; C<span class="hidden">&#8681;</span><sub>2</sub> n) &#8804; (run_tick_count &#961; C<span class="hidden">&#8681;</span><sub>1</sub> n)}&#8250;</span></span></span><span>
</span><span>  </span><span class="comment">&#8213; &#8249;@{term &#8249;C<span class="hidden">&#8681;</span><sub>1</sub> strictly precedes C<span class="hidden">&#8681;</span><sub>2</sub>&#8250;} means that each tick on @{term &#8249;C<span class="hidden">&#8681;</span><sub>2</sub>&#8250;}
        must be preceded by at least one tick on @{term &#8249;C<span class="hidden">&#8681;</span><sub>1</sub>&#8250;} at a previous instant.
        Therefore, at each instant n, the number of ticks on @{term &#8249;C<span class="hidden">&#8681;</span><sub>2</sub>&#8250;}
        must be less or equal to the number of ticks on @{term &#8249;C<span class="hidden">&#8681;</span><sub>1</sub>&#8250;} 
        at instant n - 1.&#8250;</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; C<span class="hidden">&#8681;</span><sub>1</sub> strictly precedes C<span class="hidden">&#8681;</span><sub>2</sub> &#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> =
        {&#961;. &#8704;n::nat. (run_tick_count &#961; C<span class="hidden">&#8681;</span><sub>2</sub> n) &#8804; (run_tick_count_strictly &#961; C<span class="hidden">&#8681;</span><sub>1</sub> n)}&#8250;</span></span></span><span>
</span><span>  </span><span class="comment">&#8213; &#8249;@{term &#8249;C<span class="hidden">&#8681;</span><sub>1</sub> kills C<span class="hidden">&#8681;</span><sub>2</sub>&#8250;} means that when @{term &#8249;C<span class="hidden">&#8681;</span><sub>1</sub>&#8250;} ticks, @{term &#8249;C<span class="hidden">&#8681;</span><sub>2</sub>&#8250;}
        cannot tick and is not allowed to tick at any further instant.&#8250;</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; C<span class="hidden">&#8681;</span><sub>1</sub> kills C<span class="hidden">&#8681;</span><sub>2</sub> &#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> =
        {&#961;. &#8704;n::nat. ticks ((Rep_run &#961;) n C<span class="hidden">&#8681;</span><sub>1</sub>)
                        &#10230; (&#8704;m&#8805;n. &#172; ticks ((Rep_run &#961;) m C<span class="hidden">&#8681;</span><sub>2</sub>))}&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; master delayed by d on counter implies slave &#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> =
    &#8213; &#8249;
      When master ticks, we count d ticks on measuring and we must have a tick on slave.
    &#8250;
        {&#961;. &#8704;n. ticks ((Rep_run &#961;) n master) &#10230;
                 (
                  &#8704;m &#8805; n.  counted_ticks &#961; counter n m d
                            &#10230; ticks ((Rep_run &#961;) m slave)
                 )
        }&#8250;</span></span></span><span>
</span><span> 	</span><span class="comment">&#8213; &#8249;Additional constraints for the operational semantics&#8250;</span><span>
</span><span>  </span><span class="comment">&#8213; &#8249;@{term &#8249;C<span class="hidden">&#8681;</span><sub>1</sub> sporadic&#9839; &#10631;&#964;<span class="hidden">&#8681;</span><sub>v</sub><span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>r</sub>(C<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>s</sub><span class="hidden">&#8681;</span><sub>t</sub>, n<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>s</sub><span class="hidden">&#8681;</span><sub>t</sub>) &#8853; &#948;&#964;&#10632; on C<span class="hidden">&#8681;</span><sub>2</sub>&#8250;} means that @{term &#8249;C<span class="hidden">&#8681;</span><sub>1</sub>&#8250;} should tick at an 
      instant where the time on @{term &#8249;C<span class="hidden">&#8681;</span><sub>2</sub>&#8250;} is @{term &#8249;&#10631;&#964;<span class="hidden">&#8681;</span><sub>v</sub><span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>r</sub>(C<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>s</sub><span class="hidden">&#8681;</span><sub>t</sub>, n<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>s</sub><span class="hidden">&#8681;</span><sub>t</sub>) &#8853; &#948;&#964;&#10632;&#8250;}.&#8250;</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; C<span class="hidden">&#8681;</span><sub>1</sub> sporadic&#9839; &#10631;&#964;<span class="hidden">&#8681;</span><sub>v</sub><span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>r</sub>(C<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>s</sub><span class="hidden">&#8681;</span><sub>t</sub>, n<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>s</sub><span class="hidden">&#8681;</span><sub>t</sub>) &#8853; &#948;&#964;&#10632; on C<span class="hidden">&#8681;</span><sub>2</sub> &#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> =
        {&#961;. &#8707;n::nat. ticks ((Rep_run &#961;) n C<span class="hidden">&#8681;</span><sub>1</sub>) &#8743; time ((Rep_run &#961;) n C<span class="hidden">&#8681;</span><sub>2</sub>) = time ((Rep_run &#961;) n<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>s</sub><span class="hidden">&#8681;</span><sub>t</sub> C<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>s</sub><span class="hidden">&#8681;</span><sub>t</sub>) + &#948;&#964; }&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; from n delay count d on counter implies slave &#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> =
    &#8213; &#8249;
     Count d ticks on counter from instant n and put a tick on slave.
    &#8250;
        {&#961;. &#8704;m &#8805; n. counted_ticks &#961; counter n m d
                       &#10230; ticks ((Rep_run &#961;) m slave)}&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Denotational interpretation for TESL formulae&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  To satisfy a formula, a run has to satisfy the conjunction of its atomic 
  formulae. Therefore, the interpretation of a formula is the intersection
  of the interpretations of its components.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>TESL_interpretation</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;&#964;::linordered_field) TESL_formula &#8658; &#39;&#964; run set&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; _ &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; [] &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = {_. True}&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#966; # &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#10214; &#966; &#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> &#8745; &#10214;&#10214; &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TESL_interpretation_homo</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; &#966; &#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> &#8745; &#10214;&#10214; &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#10214;&#10214; &#966; # &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Image interpretation lemma&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TESL_interpretation_image</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#8898; ((&#955;&#966;. &#10214; &#966; &#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>) ` set &#934;)&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>&#934;</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Expansion law&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Similar to the expansion laws of lattices.&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TESL_interp_homo_append</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#934;<span class="hidden">&#8681;</span><sub>1</sub> @ &#934;<span class="hidden">&#8681;</span><sub>2</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#10214;&#10214; &#934;<span class="hidden">&#8681;</span><sub>1</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> &#8745; &#10214;&#10214; &#934;<span class="hidden">&#8681;</span><sub>2</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>&#934;<span class="hidden">&#8681;</span><sub>1</sub></span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Equational laws for the denotation of TESL formulae&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TESL_interp_assoc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; (&#934;<span class="hidden">&#8681;</span><sub>1</sub> @ &#934;<span class="hidden">&#8681;</span><sub>2</sub>) @ &#934;<span class="hidden">&#8681;</span><sub>3</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#10214;&#10214; &#934;<span class="hidden">&#8681;</span><sub>1</sub> @ (&#934;<span class="hidden">&#8681;</span><sub>2</sub> @ &#934;<span class="hidden">&#8681;</span><sub>3</sub>) &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TESL_interp_commute</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#934;<span class="hidden">&#8681;</span><sub>1</sub> @ &#934;<span class="hidden">&#8681;</span><sub>2</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#10214;&#10214; &#934;<span class="hidden">&#8681;</span><sub>2</sub> @ &#934;<span class="hidden">&#8681;</span><sub>1</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>TESL_interp_homo_append</span><span> </span><span>inf_sup_aci</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TESL_interp_left_commute</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#934;<span class="hidden">&#8681;</span><sub>1</sub> @ (&#934;<span class="hidden">&#8681;</span><sub>2</sub> @ &#934;<span class="hidden">&#8681;</span><sub>3</sub>) &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#10214;&#10214; &#934;<span class="hidden">&#8681;</span><sub>2</sub> @ (&#934;<span class="hidden">&#8681;</span><sub>1</sub> @ &#934;<span class="hidden">&#8681;</span><sub>3</sub>) &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>TESL_interp_homo_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TESL_interp_idem</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#934; @ &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#10214;&#10214; &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TESL_interp_homo_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TESL_interp_left_idem</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#934;<span class="hidden">&#8681;</span><sub>1</sub> @ (&#934;<span class="hidden">&#8681;</span><sub>1</sub> @ &#934;<span class="hidden">&#8681;</span><sub>2</sub>) &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#10214;&#10214; &#934;<span class="hidden">&#8681;</span><sub>1</sub> @ &#934;<span class="hidden">&#8681;</span><sub>2</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TESL_interp_homo_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TESL_interp_right_idem</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; (&#934;<span class="hidden">&#8681;</span><sub>1</sub> @ &#934;<span class="hidden">&#8681;</span><sub>2</sub>) @ &#934;<span class="hidden">&#8681;</span><sub>2</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#10214;&#10214; &#934;<span class="hidden">&#8681;</span><sub>1</sub> @ &#934;<span class="hidden">&#8681;</span><sub>2</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>TESL_interp_homo_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>TESL_interp_aci</span><span> </span><span class="delimiter">=</span><span> </span><span>TESL_interp_commute</span><span>
</span><span>                         </span><span>TESL_interp_assoc</span><span>
</span><span>                         </span><span>TESL_interp_left_commute</span><span>
</span><span>                         </span><span>TESL_interp_left_idem</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;The empty formula is the identity element.&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TESL_interp_neutral1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; [] @ &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#10214;&#10214; &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TESL_interp_neutral2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#934; @ [] &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#10214;&#10214; &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decreasing interpretation of TESL formulae&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  Adding constraints to a TESL formula reduces the number of satisfying runs.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TESL_sem_decreases_head</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> &#8839; &#10214;&#10214; &#966; # &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TESL_sem_decreases_tail</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> &#8839; &#10214;&#10214; &#934; @ [&#966;] &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>TESL_interp_homo_append</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  Repeating a formula in a specification does not change the specification.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TESL_interp_formula_stuttering</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#966; &#8712; set &#934;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#966; # &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#10214;&#10214; &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#966; # &#934; = [&#966;] @ &#934;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#966; # &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#10214;&#10214; [&#966;] &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> &#8745; &#10214;&#10214; &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TESL_interp_homo_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>TESL_interpretation_image</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  Removing duplicate formulae in a specification does not change the specification.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TESL_interp_remdups_absorb</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#10214;&#10214; remdups &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>&#934;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Cons</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TESL_interp_formula_stuttering</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  Specifications that contain the same formulae have the same semantics.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TESL_interp_set_lifting</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set &#934; = set &#934;&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#10214;&#10214; &#934;&#39; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>     
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set (remdups &#934;) = set (remdups &#934;&#39;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fxpnt&#934;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8898; ((&#955;&#966;. &#10214; &#966; &#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>) ` set &#934;) = &#10214;&#10214; &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>TESL_interpretation_image</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fxpnt&#934;&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8898; ((&#955;&#966;. &#10214; &#966; &#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>) ` set &#934;&#39;) = &#10214;&#10214; &#934;&#39; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>TESL_interpretation_image</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8898; ((&#955;&#966;. &#10214; &#966; &#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>) ` set &#934;) = &#8898; ((&#955;&#966;. &#10214; &#966; &#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>) ` set &#934;&#39;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TESL_interp_remdups_absorb</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  The semantics of specifications is contravariant with respect to their inclusion.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>TESL_interp_decreases_setinc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set &#934; &#8838; set &#934;&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> &#8839; &#10214;&#10214; &#934;&#39; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>&#934;<span class="hidden">&#8681;</span><sub>r</sub></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>decompose</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set (&#934; @ &#934;<span class="hidden">&#8681;</span><sub>r</sub>) = set &#934;&#39;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set (&#934; @ &#934;<span class="hidden">&#8681;</span><sub>r</sub>) = set &#934;&#39;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(set &#934;) &#8746; (set &#934;<span class="hidden">&#8681;</span><sub>r</sub>) = set &#934;&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>decompose</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#934;&#39; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#10214;&#10214; &#934; @ &#934;<span class="hidden">&#8681;</span><sub>r</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TESL_interp_set_lifting</span><span> </span><span>decompose</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#934; @ &#934;<span class="hidden">&#8681;</span><sub>r</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#10214;&#10214; &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> &#8745; &#10214;&#10214; &#934;<span class="hidden">&#8681;</span><sub>r</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>TESL_interp_homo_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> &#8839; &#10214;&#10214; &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> &#8745; &#10214;&#10214; &#934;<span class="hidden">&#8681;</span><sub>r</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TESL_interp_decreases_add_head</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set &#934; &#8838; set &#934;&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#966; # &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> &#8839; &#10214;&#10214; &#966; # &#934;&#39; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>TESL_interp_decreases_setinc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TESL_interp_decreases_add_tail</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set &#934; &#8838; set &#934;&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#934; @ [&#966;] &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> &#8839; &#10214;&#10214; &#934;&#39; @ [&#966;] &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TESL_interp_decreases_setinc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>TESL_interpretation_image</span><span> </span><span>dual_order.trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TESL_interp_absorb1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set &#934;<span class="hidden">&#8681;</span><sub>1</sub> &#8838; set &#934;<span class="hidden">&#8681;</span><sub>2</sub>&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#934;<span class="hidden">&#8681;</span><sub>1</sub> @ &#934;<span class="hidden">&#8681;</span><sub>2</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#10214;&#10214; &#934;<span class="hidden">&#8681;</span><sub>2</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Int_absorb1</span><span> </span><span>TESL_interp_decreases_setinc</span><span>
</span><span>                          </span><span>TESL_interp_homo_append</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TESL_interp_absorb2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set &#934;<span class="hidden">&#8681;</span><sub>2</sub> &#8838; set &#934;<span class="hidden">&#8681;</span><sub>1</sub>&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#934;<span class="hidden">&#8681;</span><sub>1</sub> @ &#934;<span class="hidden">&#8681;</span><sub>2</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#10214;&#10214; &#934;<span class="hidden">&#8681;</span><sub>1</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>TESL_interp_absorb1</span><span> </span><span>TESL_interp_commute</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Some special cases&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NoSporadic_stable</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> &#8838; &#10214;&#10214; NoSporadic &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>filter_is_subset</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set (NoSporadic &#934;) &#8838; set &#934;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>TESL_interp_decreases_setinc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NoSporadic_idem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> &#8745; &#10214;&#10214; NoSporadic &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub> = &#10214;&#10214; &#934; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>T</sub><span class="hidden">&#8681;</span><sub>E</sub><span class="hidden">&#8681;</span><sub>S</sub><span class="hidden">&#8681;</span><sub>L</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NoSporadic_stable</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NoSporadic_setinc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set (NoSporadic &#934;) &#8838; set &#934;&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>filter_is_subset</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>dummyT0</span><span>    </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;t<span class="hidden">&#8681;</span><sub>0</sub>&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>dummyDeltaT</span><span> </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#948;t&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
</html>
