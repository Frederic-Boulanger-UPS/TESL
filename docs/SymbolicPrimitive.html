<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory SymbolicPrimitive (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory SymbolicPrimitive</h1>

<span class="command">theory</span> <span class="name">SymbolicPrimitive</span><br/>
<span class="keyword">imports</span> <a href="Run.html"><span class="name">Run</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Symbolic Primitives for Building Runs&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>SymbolicPrimitive</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Run</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  We define here the primitive constraints on runs, towards which we translate
  TESL specifications in the operational semantics.
  These constraints refer to a specific symbolic run and can therefore access
  properties of the run at particular instants (for instance, the fact that a clock
  ticks at instant @{term &#8249;n&#8250;} of the run, or the time on a given clock at 
  that instant).

  In the previous chapters, we had no reference to particular instants of a run 
  because the TESL language should be invariant by stuttering in order to allow 
  the composition of specifications: adding an instant where no clock ticks to 
  a run that satisfies a formula should yield another run that satisfies the 
  same formula. However, when constructing runs that satisfy a formula, we
  need to be able to refer to the time or hamlet of a clock at a given instant.
&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  Counter expressions are used to get the number of ticks of a clock up to 
  (strictly or not) a given instant index.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>cnt_expr</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>TickCountLess</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clock&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;instant_index&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;#<span class="hidden">&#8679;</span><sup>&lt;</sup>&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="delimiter">|</span><span> </span><span>TickCountLeq</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clock&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;instant_index&#8250;</span></span></span><span>  </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;#<span class="hidden">&#8679;</span><sup>&#8804;</sup>&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249; Symbolic Primitives for Runs &#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  Tag values are used to refer to the time on a clock at a given instant index.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>tag_val</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>TSchematic</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clock * instant_index&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#964;<span class="hidden">&#8681;</span><sub>v</sub><span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>r</sub>&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">&#39;&#964;</span><span> </span><span>constr</span><span> </span><span class="delimiter">=</span><span>
</span><span class="comment">&#8213; &#8249;@{term &#8249;c &#8659; n @ &#964;&#8250;} constrains clock @{term &#8249;c&#8250;} to have time @{term &#8249;&#964;&#8250;}
    at instant @{term &#8249;n&#8250;} of the run.&#8250;</span><span>
</span><span>  </span><span>Timestamp</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clock&#8250;</span></span></span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;instant_index&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;&#964; tag_const&#8250;</span></span></span><span>         </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8659; _ @ _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="comment">&#8213; &#8249;@{term &#8249;m @ n &#8853; &#948;t &#8658; s&#8250;} constrains clock @{term &#8249;s&#8250;} to tick at the
    first instant at which the time on @{term &#8249;m&#8250;} has increased by @{term &#8249;&#948;t&#8250;}
    from the value it had at instant @{term &#8249;n&#8250;} of the run.&#8250;</span><span>
</span><span class="delimiter">|</span><span> </span><span>TimeDelay</span><span>     </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clock&#8250;</span></span></span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;instant_index&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;&#964; tag_const&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clock&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ @ _ &#8853; _ &#8658; _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="comment">&#8213; &#8249;@{term &#8249;c &#8657; n&#8250;} constrains clock @{term &#8249;c&#8250;} to tick
    at instant @{term &#8249;n&#8250;} of the run.&#8250;</span><span>
</span><span class="delimiter">|</span><span> </span><span>Ticks</span><span>         </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clock&#8250;</span></span></span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;instant_index&#8250;</span></span></span><span>                        </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8657; _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="comment">&#8213; &#8249;@{term &#8249;c &#172;&#8657; n&#8250;} constrains clock @{term &#8249;c&#8250;} not to tick
    at instant @{term &#8249;n&#8250;} of the run.&#8250;</span><span>
</span><span class="delimiter">|</span><span> </span><span>NotTicks</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clock&#8250;</span></span></span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;instant_index&#8250;</span></span></span><span>                        </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#172;&#8657; _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="comment">&#8213; &#8249;@{term &#8249;c &#172;&#8657; &lt; n&#8250;} constrains clock @{term &#8249;c&#8250;} not to tick
    before instant @{term &#8249;n&#8250;} of the run.&#8250;</span><span>
</span><span class="delimiter">|</span><span> </span><span>NotTicksUntil</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clock&#8250;</span></span></span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;instant_index&#8250;</span></span></span><span>                        </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#172;&#8657; &lt; _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="comment">&#8213; &#8249;@{term &#8249;c &#172;&#8657; &#8805; n&#8250;} constrains clock @{term &#8249;c&#8250;} not to tick
    at and after instant @{term &#8249;n&#8250;} of the run.&#8250;</span><span>
</span><span class="delimiter">|</span><span> </span><span>NotTicksFrom</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;clock&#8250;</span></span></span><span>   </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;instant_index&#8250;</span></span></span><span>                        </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#172;&#8657; &#8805; _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="comment">&#8213; &#8249;@{term &#8249;&#8970;&#964;<span class="hidden">&#8681;</span><sub>1</sub>, &#964;<span class="hidden">&#8681;</span><sub>2</sub>&#8971; &#8712; R&#8250;} constrains tag variables @{term &#8249;&#964;<span class="hidden">&#8681;</span><sub>1</sub>&#8250;} and  @{term &#8249;&#964;<span class="hidden">&#8681;</span><sub>2</sub>&#8250;} 
    to be in relation @{term &#8249;R&#8250;}.&#8250;</span><span>
</span><span class="delimiter">|</span><span> </span><span>TagArith</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tag_val&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;tag_val&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;&#964; tag_const &#215; &#39;&#964; tag_const) &#8658; bool&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8970;_, _&#8971; &#8712; _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="comment">&#8213; &#8249;@{term &#8249;&#8968;k<span class="hidden">&#8681;</span><sub>1</sub>, k<span class="hidden">&#8681;</span><sub>2</sub>&#8969; &#8712; R&#8250;} constrains counter expressions @{term &#8249;k<span class="hidden">&#8681;</span><sub>1</sub>&#8250;} and  @{term &#8249;k<span class="hidden">&#8681;</span><sub>2</sub>&#8250;} 
    to be in relation @{term &#8249;R&#8250;}.&#8250;</span><span>
</span><span class="delimiter">|</span><span> </span><span>TickCntArith</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cnt_expr&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cnt_expr&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(nat &#215; nat) &#8658; bool&#8250;</span></span></span><span>      </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8968;_, _&#8969; &#8712; _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="comment">&#8213; &#8249;@{term &#8249;k<span class="hidden">&#8681;</span><sub>1</sub> &#8828; k<span class="hidden">&#8681;</span><sub>2</sub>&#8250;} constrains counter expression @{term &#8249;k<span class="hidden">&#8681;</span><sub>1</sub>&#8250;} to be less or equal 
    to counter expression @{term &#8249;k<span class="hidden">&#8681;</span><sub>2</sub>&#8250;}.&#8250;</span><span>
</span><span class="delimiter">|</span><span> </span><span>TickCntLeq</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cnt_expr&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;cnt_expr&#8250;</span></span></span><span>                            </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#8828; _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;&#964;</span><span> </span><span>system</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;&#964; constr list&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  The abstract machine has configurations composed of:
  &#9642; the past @{term&#8249;&#915;&#8250;}, which captures choices that have already be made as a 
    list of symbolic primitive constraints on the run;
  &#9642; the current index @{term &#8249;n&#8250;}, which is the index of the present instant;
  &#9642; the present @{term&#8249;&#936;&#8250;}, which captures the formulae that must be satisfied
    in the current instant;
  &#9642; the future @{term&#8249;&#934;&#8250;}, which captures the constraints on the future of the run.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;&#964;</span><span> </span><span>config</span><span> </span><span class="delimiter">=</span><span>
</span><span>                </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#39;&#964; system * instant_index * &#39;&#964; TESL_formula * &#39;&#964; TESL_formula&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Semantics of Primitive Constraints &#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  The semantics of the primitive constraints is defined in a way similar to
  the semantics of TESL formulae.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>counter_expr_eval</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;&#964;::linordered_field) run &#8658; cnt_expr &#8658; nat&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; _ &#8866; _ &#10215;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>n</sub><span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8681;</span><sub>x</sub><span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub>&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; &#961; &#8866; #<span class="hidden">&#8679;</span><sup>&lt;</sup> clk indx &#10215;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>n</sub><span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8681;</span><sub>x</sub><span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub> = run_tick_count_strictly &#961; clk indx&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; &#961; &#8866; #<span class="hidden">&#8679;</span><sup>&#8804;</sup> clk indx &#10215;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>n</sub><span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8681;</span><sub>x</sub><span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub> = run_tick_count &#961; clk indx&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>symbolic_run_interpretation_primitive</span><span>
</span><span>  </span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;&#964;::linordered_field) constr &#8658; &#39;&#964; run set&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; _ &#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; K &#8657; n  &#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>     = {&#961;. hamlet ((Rep_run &#961;) n K) }&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; K @ n<span class="hidden">&#8681;</span><sub>0</sub> &#8853; &#948;t &#8658; K&#39; &#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> =
                  {&#961;. &#8704;n &#8805; n<span class="hidden">&#8681;</span><sub>0</sub>. first_time &#961; K n (time ((Rep_run &#961;) n<span class="hidden">&#8681;</span><sub>0</sub> K) + &#948;t)
                               &#10230; hamlet ((Rep_run &#961;) n K&#39;)}&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; K &#172;&#8657; n &#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>     = {&#961;. &#172;hamlet ((Rep_run &#961;) n K) }&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; K &#172;&#8657; &lt; n &#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>   = {&#961;. &#8704;i &lt; n. &#172; hamlet ((Rep_run &#961;) i K)}&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; K &#172;&#8657; &#8805; n &#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>   = {&#961;. &#8704;i &#8805; n. &#172; hamlet ((Rep_run &#961;) i K) }&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; K &#8659; n @ &#964; &#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = {&#961;. time ((Rep_run &#961;) n K) = &#964; }&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; &#8970;&#964;<span class="hidden">&#8681;</span><sub>v</sub><span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>r</sub>(K<span class="hidden">&#8681;</span><sub>1</sub>, n<span class="hidden">&#8681;</span><sub>1</sub>), &#964;<span class="hidden">&#8681;</span><sub>v</sub><span class="hidden">&#8681;</span><sub>a</sub><span class="hidden">&#8681;</span><sub>r</sub>(K<span class="hidden">&#8681;</span><sub>2</sub>, n<span class="hidden">&#8681;</span><sub>2</sub>)&#8971; &#8712; R &#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> =
    { &#961;. R (time ((Rep_run &#961;) n<span class="hidden">&#8681;</span><sub>1</sub> K<span class="hidden">&#8681;</span><sub>1</sub>), time ((Rep_run &#961;) n<span class="hidden">&#8681;</span><sub>2</sub> K<span class="hidden">&#8681;</span><sub>2</sub>)) }&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; &#8968;e<span class="hidden">&#8681;</span><sub>1</sub>, e<span class="hidden">&#8681;</span><sub>2</sub>&#8969; &#8712; R &#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = { &#961;. R (&#10214; &#961; &#8866; e<span class="hidden">&#8681;</span><sub>1</sub> &#10215;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>n</sub><span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8681;</span><sub>x</sub><span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub>, &#10214; &#961; &#8866; e<span class="hidden">&#8681;</span><sub>2</sub> &#10215;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>n</sub><span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8681;</span><sub>x</sub><span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub>) }&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; cnt_e<span class="hidden">&#8681;</span><sub>1</sub> &#8828; cnt_e<span class="hidden">&#8681;</span><sub>2</sub> &#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = { &#961;. &#10214; &#961; &#8866; cnt_e<span class="hidden">&#8681;</span><sub>1</sub> &#10215;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>n</sub><span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8681;</span><sub>x</sub><span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub> &#8804; &#10214; &#961; &#8866; cnt_e<span class="hidden">&#8681;</span><sub>2</sub> &#10215;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>n</sub><span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8681;</span><sub>x</sub><span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub> }&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  The composition of primitive constraints is their conjunction, and we get the
  set of satisfying runs by intersection.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>symbolic_run_interpretation</span><span>
</span><span>  </span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;&#964;::linordered_field) constr list &#8658; (&#39;&#964;::linordered_field) run set&#8250;</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; _ &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; [] &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = {&#961;. True }&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#947; # &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = &#10214; &#947; &#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> &#8745; &#10214;&#10214; &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symbolic_run_interp_cons_morph</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214; &#947; &#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> &#8745; &#10214;&#10214; &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = &#10214;&#10214; &#947; # &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>consistent_context</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;&#964;::linordered_field) constr list &#8658; bool&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_context &#915; &#8801; ( &#10214;&#10214; &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> &#8800; {}) &#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Defining a method for witness construction&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  In order to build a run, we can start from an initial run in which no clock 
  ticks and the time is always 0 on any clock.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>initial_run</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;&#964;::linordered_field) run&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#961;<span class="hidden">&#8681;</span><sub>&#8857;</sub>&#8250;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#961;<span class="hidden">&#8681;</span><sub>&#8857;</sub> &#8801; Abs_run ((&#955;_ _. (False, &#964;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>s</sub><span class="hidden">&#8681;</span><sub>t</sub> 0)) ::nat &#8658; clock &#8658; (bool &#215; &#39;&#964; tag_const))&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  To help avoiding that time flows backward, setting the time on a clock at a given 
  instant sets it for the future instants too.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>time_update</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;nat &#8658; clock &#8658; (&#39;&#964;::linordered_field) tag_const &#8658; (nat &#8658; &#39;&#964; instant)
      &#8658; (nat &#8658; &#39;&#964; instant)&#8250;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;time_update n K &#964; &#961; = (&#955;n&#39; K&#39;. if K = K&#39; &#8743; n &#8804; n&#39;
                                  then (hamlet (&#961; n K), &#964;)
                                  else &#961; n&#39; K&#39;)&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Rules and properties of consistence&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>context_consistency_preservationI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;consistent_context ((&#947;::(&#39;&#964;::linordered_field) constr)#&#915;) &#10233; consistent_context &#915;&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>consistent_context_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment">&#8213; &#8249;This is very restrictive&#8250;</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>context_independency</span><span>
</span><span>  </span><span class="delimiter">::</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#39;&#964;::linordered_field) constr &#8658; &#39;&#964; constr list &#8658; bool&#8250;</span></span></span><span> </span><span class="delimiter">(</span><span class="cartouche"><span class="delete"><span class="delete">&#8249;_ &#10781; _&#8250;</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>NotTicks_independency</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(K &#8657; n) &#8713; set &#915; &#10233; (K &#172;&#8657; n) &#10781; &#915;&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Ticks_independency</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(K &#172;&#8657; n) &#8713; set &#915; &#10233; (K &#8657; n) &#10781; &#915;&#8250;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Timestamp_independency</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(&#8708;&#964;&#39;. &#964;&#39; = &#964; &#8743; (K &#8659; n @ &#964;) &#8712; set &#915;) &#10233; (K &#8659; n @ &#964;) &#10781; &#915;&#8250;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Major Theorems&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Interpretation of a context&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  The interpretation of a context is the intersection of the interpretation 
  of its components.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>symrun_interp_fixpoint</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8898; ((&#955;&#947;. &#10214; &#947; &#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>) ` set &#915;) = &#10214;&#10214; &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>&#915;</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Expansion law&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Similar to the expansion laws of lattices&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>symrun_interp_expansion</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#915;<span class="hidden">&#8681;</span><sub>1</sub> @ &#915;<span class="hidden">&#8681;</span><sub>2</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = &#10214;&#10214; &#915;<span class="hidden">&#8681;</span><sub>1</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> &#8745; &#10214;&#10214; &#915;<span class="hidden">&#8681;</span><sub>2</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>&#915;<span class="hidden">&#8681;</span><sub>1</sub></span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Equations for the interpretation of symbolic primitives&#8250;</span></span></span><span> 
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;General laws&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symrun_interp_assoc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; (&#915;<span class="hidden">&#8681;</span><sub>1</sub> @ &#915;<span class="hidden">&#8681;</span><sub>2</sub>) @ &#915;<span class="hidden">&#8681;</span><sub>3</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = &#10214;&#10214; &#915;<span class="hidden">&#8681;</span><sub>1</sub> @ (&#915;<span class="hidden">&#8681;</span><sub>2</sub> @ &#915;<span class="hidden">&#8681;</span><sub>3</sub>) &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symrun_interp_commute</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#915;<span class="hidden">&#8681;</span><sub>1</sub> @ &#915;<span class="hidden">&#8681;</span><sub>2</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = &#10214;&#10214; &#915;<span class="hidden">&#8681;</span><sub>2</sub> @ &#915;<span class="hidden">&#8681;</span><sub>1</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>symrun_interp_expansion</span><span> </span><span>inf_sup_aci</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symrun_interp_left_commute</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#915;<span class="hidden">&#8681;</span><sub>1</sub> @ (&#915;<span class="hidden">&#8681;</span><sub>2</sub> @ &#915;<span class="hidden">&#8681;</span><sub>3</sub>) &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = &#10214;&#10214; &#915;<span class="hidden">&#8681;</span><sub>2</sub> @ (&#915;<span class="hidden">&#8681;</span><sub>1</sub> @ &#915;<span class="hidden">&#8681;</span><sub>3</sub>) &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>symrun_interp_expansion</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symrun_interp_idem</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#915; @ &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = &#10214;&#10214; &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>symrun_interp_expansion</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symrun_interp_left_idem</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#915;<span class="hidden">&#8681;</span><sub>1</sub> @ (&#915;<span class="hidden">&#8681;</span><sub>1</sub> @ &#915;<span class="hidden">&#8681;</span><sub>2</sub>) &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = &#10214;&#10214; &#915;<span class="hidden">&#8681;</span><sub>1</sub> @ &#915;<span class="hidden">&#8681;</span><sub>2</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>symrun_interp_expansion</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symrun_interp_right_idem</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; (&#915;<span class="hidden">&#8681;</span><sub>1</sub> @ &#915;<span class="hidden">&#8681;</span><sub>2</sub>) @ &#915;<span class="hidden">&#8681;</span><sub>2</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = &#10214;&#10214; &#915;<span class="hidden">&#8681;</span><sub>1</sub> @ &#915;<span class="hidden">&#8681;</span><sub>2</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>symrun_interp_expansion</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>symrun_interp_aci</span><span> </span><span class="delimiter">=</span><span>  </span><span>symrun_interp_commute</span><span>
</span><span>                            </span><span>symrun_interp_assoc</span><span>
</span><span>                            </span><span>symrun_interp_left_commute</span><span>
</span><span>                            </span><span>symrun_interp_left_idem</span><span>
</span><span>
</span><span class="comment">&#8213; &#8249;Identity element&#8250;</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symrun_interp_neutral1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; [] @ &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = &#10214;&#10214; &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symrun_interp_neutral2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#915; @ [] &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = &#10214;&#10214; &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Decreasing interpretation of symbolic primitives&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  Adding constraints to a context reduces the number of satisfying runs.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TESL_sem_decreases_head</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> &#8839; &#10214;&#10214; &#947; # &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TESL_sem_decreases_tail</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> &#8839; &#10214;&#10214; &#915; @ [&#947;] &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>symrun_interp_expansion</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  Adding a constraint that is already in the context does not change the
  interpretation of the context.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symrun_interp_formula_stuttering</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#947; &#8712; set &#915;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#947; # &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = &#10214;&#10214; &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#947; # &#915; = [&#947;] @ &#915;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#947; # &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = &#10214;&#10214; [&#947;] &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> &#8745; &#10214;&#10214; &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>symrun_interp_expansion</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>symrun_interp_fixpoint</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  Removing duplicate constraints from a context does not change the
  interpretation of the context.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symrun_interp_remdups_absorb</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = &#10214;&#10214; remdups &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>&#915;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Cons</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>symrun_interp_formula_stuttering</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  Two identical sets of constraints have the same interpretation,
  the order in the context does not matter.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symrun_interp_set_lifting</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set &#915; = set &#915;&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = &#10214;&#10214; &#915;&#39; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>     
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set (remdups &#915;) = set (remdups &#915;&#39;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fxpnt&#915;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8898; ((&#955;&#947;. &#10214; &#947; &#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>) ` set &#915;) = &#10214;&#10214; &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>symrun_interp_fixpoint</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fxpnt&#915;&#39;</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8898; ((&#955;&#947;. &#10214; &#947; &#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>) ` set &#915;&#39;) = &#10214;&#10214; &#915;&#39; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>symrun_interp_fixpoint</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8898; ((&#955;&#947;. &#10214; &#947; &#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>) ` set &#915;) = &#8898; ((&#955;&#947;. &#10214; &#947; &#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>) ` set &#915;&#39;)&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>symrun_interp_remdups_absorb</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;
  The interpretation of contexts is contravariant with regard to set inclusion.
&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>symrun_interp_decreases_setinc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set &#915; &#8838; set &#915;&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> &#8839; &#10214;&#10214; &#915;&#39; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>&#915;<span class="hidden">&#8681;</span><sub>r</sub></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>decompose</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set (&#915; @ &#915;<span class="hidden">&#8681;</span><sub>r</sub>) = set &#915;&#39;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set (&#915; @ &#915;<span class="hidden">&#8681;</span><sub>r</sub>) = set &#915;&#39;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(set &#915;) &#8746; (set &#915;<span class="hidden">&#8681;</span><sub>r</sub>) = set &#915;&#39;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>decompose</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#915;&#39; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = &#10214;&#10214; &#915; @ &#915;<span class="hidden">&#8681;</span><sub>r</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>symrun_interp_set_lifting</span><span> </span><span>decompose</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#915; @ &#915;<span class="hidden">&#8681;</span><sub>r</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = &#10214;&#10214; &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> &#8745; &#10214;&#10214; &#915;<span class="hidden">&#8681;</span><sub>r</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>symrun_interp_expansion</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> &#8839; &#10214;&#10214; &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> &#8745; &#10214;&#10214; &#915;<span class="hidden">&#8681;</span><sub>r</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symrun_interp_decreases_add_head</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set &#915; &#8838; set &#915;&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#947; # &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> &#8839; &#10214;&#10214; &#947; # &#915;&#39; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>symrun_interp_decreases_setinc</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symrun_interp_decreases_add_tail</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set &#915; &#8838; set &#915;&#39;&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#915; @ [&#947;] &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> &#8839; &#10214;&#10214; &#915;&#39; @ [&#947;] &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>symrun_interp_decreases_setinc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#915;&#39; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> &#8838; &#10214;&#10214; &#915; &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>symrun_interp_expansion</span><span> </span><span>dual_order.trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symrun_interp_absorb1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set &#915;<span class="hidden">&#8681;</span><sub>1</sub> &#8838; set &#915;<span class="hidden">&#8681;</span><sub>2</sub>&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#915;<span class="hidden">&#8681;</span><sub>1</sub> @ &#915;<span class="hidden">&#8681;</span><sub>2</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = &#10214;&#10214; &#915;<span class="hidden">&#8681;</span><sub>2</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Int_absorb1</span><span> </span><span>symrun_interp_decreases_setinc</span><span>
</span><span>                          </span><span>symrun_interp_expansion</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symrun_interp_absorb2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;set &#915;<span class="hidden">&#8681;</span><sub>2</sub> &#8838; set &#915;<span class="hidden">&#8681;</span><sub>1</sub>&#8250;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#10214;&#10214; &#915;<span class="hidden">&#8681;</span><sub>1</sub> @ &#915;<span class="hidden">&#8681;</span><sub>2</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub> = &#10214;&#10214; &#915;<span class="hidden">&#8681;</span><sub>1</sub> &#10215;&#10215;<span class="hidden">&#8681;</span><sub>p</sub><span class="hidden">&#8681;</span><sub>r</sub><span class="hidden">&#8681;</span><sub>i</sub><span class="hidden">&#8681;</span><sub>m</sub>&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>symrun_interp_absorb1</span><span> </span><span>symrun_interp_commute</span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
</html>
